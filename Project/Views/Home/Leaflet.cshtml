@* Leaflet.cshtml — map + in-page modal for Add Report *@
@* Einar, Arild *@

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Leaflet – Report Obstacles</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin="" />

    <!-- (Optional) your own stylesheet -->
    <link rel="stylesheet" href="map.css">

    <style>
        html, body {
            height: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: 86vh;
            position: relative;
        }

        /* Centered coordinate readout (non-blocking) */
        .coordinate {
            position: absolute;
            bottom: 1px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--base-color);
            padding: 6px 10px;
            border-radius: 6px;
            font: 12px/1 system-ui, sans-serif;
            z-index: 1000;
            pointer-events: none;
        }

        

        /* Dialog look */
        dialog#reportDialog {
            padding: 0;
            border: none;
            width: 70vw;
            height: 80vh;
            max-width: 900px;
            max-height: 850px;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        dialog::backdrop {
            background: rgba(0,0,0,0.35);
        }
                
    </style>
</head>

<body>
    <div id="map">
        <div class="coordinate leaflet-control"></div>
        <div id="obstacleBox" class="leaflet-control">Report</div>
    </div>

    <!-- Downloaded version of Leaflet; wwwroot/lib/LeafletMap -->
    <link rel="stylesheet" href="~/lib/LeafletMap/leaflet.css" />
    <script src="~/lib/LeafletMap/leaflet.js"></script>
     
    <!-- In-page modal that loads the Add Report page -->
    <dialog id="reportDialog">
        <div class="dialog-body">
            <div class="dialog-header">
                <strong class="formTitle">ADD REPORT</strong>
                <button id="reportClose" class="btnBack" type="button">Close</button>
            </div>
            <iframe id="reportFrame"></iframe>
        </div>
    </dialog>

    <script>

        //CustomElementRegistry Helicopter icon for your location
        const userIcon = L.icon({
            iconUrl: '@Url.Content("~/Content/Images/Heli2.png")',
            iconSize: [40, 40],        // pixel size of the image
            iconAnchor: [18, 36],      // "tip" of the pin (x,y from top-left)
            popupAnchor: [0, -30],     // where popups open relative to the anchor
            tooltipAnchor: [0, -24],   // optional
            className: 'leaflet-user-icon' // optional CSS hook
        });
        
        // ---------------- Map init ----------------
        window.map = L.map('map', { minZoom: 4 }).setView([58.1638332, 7.9812789], 16);

        const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(window.map);

        const darkMode = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.{ext}', {
            minZoom: 0, maxZoom: 20, ext: 'png',
            attribution: '&copy; Stadia Maps & OpenMapTiles & OpenStreetMap'
        });

        const googleSat = L.tileLayer('https://{s}.google.com/vt?lyrs=s&x={x}&y={y}&z={z}', {
            maxZoom: 20, subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
        });

        L.control.layers(
            { 'OSM': osm, 'Darkmode': darkMode, 'SatView': googleSat },
            {},
            { collapsed: false }
        ).addTo(map);


        // ---------------- Marker placement ----------------
        let marker = null;
        let latlngs = [];
        let polyline = null;
        let currentMode = null;
        let redDot = [];
        let redDotLayer = L.layerGroup().addTo(map);

        function setMode(mode) {
            if (currentMode === mode) {
                currentMode = null; // turn off if same mode clicked
            } else {
                currentMode = mode;
            }   

        // update button colors
            document.querySelectorAll('.leaflet-control-custom').forEach(btn => {
                btn.style.backgroundColor = (btn.dataset.mode === currentMode) ? '#a3e635' : 'white';
              });

            // leaving polyline mode → clear line + vertices
              if (currentMode !== 'polyline') {
                latlngs = [];
                if (polyline) {
                  map.removeLayer(polyline);
                  polyline = null;
                }
                // clear all vertex dots in one go
                redDotLayer.clearLayers();
                redDot = [];
              }
        // reset state when leaving marker mode
            if (currentMode !== 'marker') {
                latlngs = [];
            if (marker) {
                map.removeLayer(marker);
                marker = null;
            }
        }
    }

            // --- Map click handling ---
         map.on('click', (e) => {
            const { lat, lng } = e.latlng;

            // get the css color, since its written in CSS
            const polyColor = getComputedStyle(document.documentElement)
            .getPropertyValue('--polyline-color')
            .trim();

            // shows your coordinate when you click the map
            const el = document.querySelector('.coordinate');
            if (el) el.textContent = `lat: ${lat.toFixed(6)}, lng: ${lng.toFixed(6)}`;

            if (currentMode === 'polyline') {
              // create / extend the line
              if (!polyline) {
                latlngs = [e.latlng];
                polyline = L.polyline(latlngs, { color: polyColor }).addTo(map);
              } else {
                latlngs.push(e.latlng);
                polyline.setLatLngs(latlngs);
              }

             // addEventListener for red dot on every click
              const dot = L.circleMarker(e.latlng, {
                radius: 4,
                   color: polyColor,
                   fillColor:polyColor,
                fillOpacity: 1,
                weight: 0
              }).addTo(redDotLayer);
              dot.bringToFront();
              redDot.push(dot);

            } else if (currentMode === 'marker') {
              if (!marker) {
                marker = L.marker(e.latlng, { draggable: true }).addTo(map);

                // Updates the cordinate when marker is dragged
                marker.on('drag', (event) => {
                  const pos = event.target.getLatLng();
                  const el = document.querySelector('.coordinate');
                  if (el) el.textContent = `lat: ${pos.lat.toFixed(6)}, lng: ${pos.lng.toFixed(6)}`;
                });
              } else {
                marker.setLatLng(e.latlng);
              }
            }
            });

                // --- Polyline button ---
                const DrawPolylineControl = L.Control.extend({
                    onAdd: function () {

                        const btn = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom');

                        btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px" fill="black"><path d="M760-80q-50 0-85-35t-35-85q0-14 3-27t9-25L252-652q-12 6-25 9t-27 3q-50 0-85-35t-35-85q0-50 35-85t85-35q50 0 85 35t35 85q0 14-3 27t-9 25l400 400q12-6 25-9t27-3q50 0 85 35t35 85q0 50-35 85t-85 35Z"/></svg>';
                        btn.dataset.mode = 'polyline';
                        btn.style.backgroundColor = 'white';
                        btn.style.width = '100px';
                        btn.style.height = '100px';
                        btn.style.cursor = 'pointer';
                        btn.style.padding = '5px';
                        btn.title = 'Click to start/stop drawing a polyline';
                        L.DomEvent.on(btn, 'click', L.DomEvent.stopPropagation)
                                  .on(btn, 'click', (e) => setMode('polyline'));
                        return btn;
                    }
                });

        // --- Marker button ---

        const DrawMarkerControl = L.Control.extend({
            onAdd: function () {
                const btn = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom');

                btn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px" fill="#EA4335">
                        <path d="M480-480q33 0 56.5-23.5T560-560q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 33 23.5 56.5T480-480Zm0 400Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"/>
                    </svg>
                `;

                btn.dataset.mode = 'marker';
                btn.style.backgroundColor = 'var(--base-variant)';
                btn.style.width = '100px';
                btn.style.height = '100px';
                btn.style.cursor = 'pointer';
                btn.style.padding = '5px';
                btn.title = 'Click to start/stop placing markers';
                

                L.DomEvent.on(btn, 'click', L.DomEvent.stopPropagation)
                          .on(btn, 'click', () => setMode('marker'));

                return btn;
            }
        });


        // Add the button to the map
        map.addControl(new DrawPolylineControl({ position: 'topleft' }));
        map.addControl(new DrawMarkerControl({ position: 'topleft' }));
                
        // ---------------- Geolocation follow ----------------
        let watchId = null;
        let following = false;
        let userMarker = null;
        let accuracyCircle = null;
        

        function renderUserLocation(lat, lng, accuracy) {
            if (!userMarker) {
                userMarker = L.marker([lat, lng], {
                    title: 'You',
                    icon: userIcon,
                }).addTo(window.map);
            } else {
                userMarker.setLatLng([lat, lng]);
            }

            if (!accuracyCircle) {
                accuracyCircle = L.circle([lat, lng], {
                    radius: accuracy, color: '#2a83ff', weight: 0.3,
                    fillColor: '#2a83ff', fillOpacity: 0.1
                }).addTo(window.map);
            } else {
                accuracyCircle.setLatLng([lat, lng]).setRadius(accuracy);
            }
        }

        function onPositionSuccess(position) {
            const { latitude: lat, longitude: lng, accuracy } = position.coords;
            renderUserLocation(lat, lng, accuracy);
            if (following) {
                map.setView([lat, lng], Math.max(map.getZoom(), 16), { animate: true });
            }
        }

        function onPositionError(err) {
            const msgs = {
                1: 'Geolocation permission denied. Enable it in your browser.',
                2: 'Position unavailable. Try enabling GPS/location services.',
                3: 'Timeout. Please try again.'
            };
            alert(msgs[err.code] || 'Couldn’t get your position.');
            setFollowing(false);
        }

        function startWatch() {
            if (!('geolocation' in navigator)) {
                alert('Your browser does not support geolocation.');
                return;
            }
            if (watchId !== null) return;
            navigator.geolocation.getCurrentPosition(onPositionSuccess, onPositionError, {
                enableHighAccuracy: true, timeout: 10000, maximumAge: 0
            });
            watchId = navigator.geolocation.watchPosition(onPositionSuccess, onPositionError, {
                enableHighAccuracy: true, timeout: 20000, maximumAge: 5000
            });
        }

        function stopWatch() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
        }

        function isLocalSecure() {
            return window.isSecureContext ||
                ['localhost', '127.0.0.1', '::1'].includes(location.hostname);
        }

        function setFollowing(isOn) {
            following = isOn;
            if (isOn) {
                if (isLocalSecure()) startWatch();
                else {
                    alert('Geolocation follow requires HTTPS or localhost/127.0.0.1/::1.');
                    following = false;
                }
            } else {
                stopWatch();
            }
            if (followCtrl && followCtrl.setUi) followCtrl.setUi(following);
        }

        // Pause following when user interacts
        map.on('dragstart zoomstart', () => { if (following) setFollowing(false); });

        // Leaflet control for toggling follow
                const FollowControl = L.Control.extend({
            onAdd: function () {
                const btn = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom');
                btn.title = 'Find me';
                btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px" fill="blue"><path d="m300-300 280-80 80-280-280 80-80 280Zm180-120q-25 0-42.5-17.5T420-480q0-25 17.5-42.5T480-540q25 0 42.5 17.5T540-480q0 25-17.5 42.5T480-420Zm0 340q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"/></svg>';

                btn.style.width = '100px';
                btn.style.height = '100px';
                btn.style.padding = '5px';
                btn.style.cursor = 'pointer';
                btn.style.backgroundColor = 'var(--base-variant)';
                

                L.DomEvent.on(btn, 'click', L.DomEvent.stopPropagation)
                          .on(btn, 'click', () => setFollowing(!following));

                this._btn = btn;
                this.setUi(false);
                return btn;
            },
            setUi: function (isOn) {
                if (!this._btn) return;
                this._btn.title = isOn ? 'Following (click to pause)' : 'Find me';
                this._btn.style.background = isOn ? 'var(--base-color)' : 'var(--base-variant)';
                this._btn.style.color = isOn ? 'var(--base-color)' : 'var(--base-variant)';
            }
        });
        const followCtrl = new FollowControl({ position: 'topleft' }).addTo(window.map);

        // ---------------- Modal to add Report ----------------

        const obstacleBox = document.getElementById('obstacleBox');
        const dlg = document.getElementById('reportDialog');
        const frame = document.getElementById('reportFrame');
        const closeBtn = document.getElementById('reportClose');

        // Prevent map panning when clicking the box, but allow our click handler
        L.DomEvent.disableClickPropagation(obstacleBox);
        L.DomEvent.disableScrollPropagation(obstacleBox);

        // Close dialog via button or ESC
        closeBtn.addEventListener('click', () => dlg.close());
        dlg.addEventListener('cancel', () => dlg.close());

        function currentLatLngForForm() {
            const features = [];
            // Prefer the user’s placed marker; else use map center
            if (marker && marker.getLatLng) {
                const ll = marker.getLatLng();
                

                features.push({
                    type: "Feature",
                    geometry: {
                    coordinates: [parseFloat(ll.lng.toFixed(6)), parseFloat(ll.lat.toFixed(6))]
                },
                properties: {}
                });
            }
            
            if (polyline && polyline.getLatLngs && polyline.getLatLngs().length > 0) {
                const coords = polyline.getLatLngs().map(p => [
                    parseFloat(p.lng.toFixed(6)),
                    parseFloat(p.lat.toFixed(6))
                ]);
                features.push({
                    type: "Feature",
                    geometry: {
                        type: "LineString",
                        coordinates: coords
                },
                properties: {}
                });
            }
            if (features.length === 0) {
                const c = map.getCenter();
                features.push({
                    type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: [parseFloat(c.lng.toFixed(6)), parseFloat(c.lat.toFixed(6))]
                                },
                                properties: {}
                        });
            }
                
            return {
                type: "FeatureCollection", features};
            }

                function firstLatLng() {
                        const geoJson = currentLatLngForForm();
                        const firstFeature = geoJson.features[0];

                        if (firstFeature.geometry.type === "Point") {
                            const [lng, lat] = firstFeature.geometry.coordinates;
                            return { lat, lng };

                        } else if (firstFeature.geometry.type === "LineString") {
                            const [lng, lat] = firstFeature.geometry.coordinates[0];
                            return { lat, lng };

                        } else {
                        // Default to map center if unknown geometry
                        const c = map.getCenter();
                        return { lat: c.lat, lng: c.lng };
                                }

            }

            obstacleBox.addEventListener('click', (e) => {
            e.preventDefault();

            // ---- Build the GeoJSON ----
            const geoJsonData = currentLatLngForForm();
            const geoJsonString = JSON.stringify(geoJsonData, null, 2); // pretty-print for readability

            // ---- Determine first point for CreatePopUp URL ----
            const { lat, lng } = firstLatLng();
            const isDarkMode = document.body.classList.contains('darkmode');
            const createUrl =
                '@Url.Action("CreatePopUp", "Reports")' +
                `?lat=${encodeURIComponent(lat)}&lng=${encodeURIComponent(lng)}&darkmode=${isDarkMode}`;

            console.log("Opening Add Report at:", createUrl);
            console.log("GeoJSON to insert:", geoJsonString);

            // ---- Open the CreatePopUp form inside iframe ----
            frame.src = createUrl;
            dlg.showModal();

            // ---- When the form loads inside iframe, insert the GeoJSON ----
            frame.onload = () => {
                try {
                    const doc = frame.contentDocument || frame.contentWindow.document;
                    const geoInput = doc.querySelector('[name="NewReport.GeoJson"]');
                    if (geoInput) {
                        geoInput.value = geoJsonString;
                        console.log("GeoJSON inserted into form");
                    } else {
                        console.warn("GeoJSON input not found in CreatePopUp form");
                    }
                } catch (err) {
                    console.error("Could not access iframe form:", err);
                }
            };
        });
    </script>
</body>
</html>