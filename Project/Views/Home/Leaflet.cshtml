<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Leaflet – Report Obstacles</title>

    <!-- Load Leaflet's core CSS from CDN -->
    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin="" />

    <!-- Custom styling for the map page -->
    <link rel="stylesheet" href="map.css">

    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: calc(86vh - 4vh);
            margin-bottom: 4vh;
            position: relative;
        }
    </style>
</head>

<body>
    <div id="map">
        <div class="coordinate leaflet-control"></div>
        <div id="obstacleBox" class="leaflet-control">Report</div>
    </div>

    <!-- Local (bundled) Leaflet CSS/JS used by the application -->
    <link rel="stylesheet" href="~/lib/LeafletMap/leaflet.css" />
    <script src="~/lib/LeafletMap/leaflet.js"></script>

    <!-- Modal dialog used to host the "Add Report" form in an iframe -->
    <dialog id="reportDialog">
        <div class="dialog-body">
            <div class="dialog-header">
                <strong class="formTitle" style="font-size: 3vh">ADD REPORT</strong>
                <button id="reportClose" class="btnBack" type="button">Close</button>
            </div>
            <iframe id="reportFrame"></iframe>
        </div>
    </dialog>

    @{
        var stadiaApiKey = Context.Items["StadiaApiKey"] as string;
    }

    <script>

        // Icon used to represent the current user location (helicopter-shaped marker)
        const userIcon = L.divIcon({
            html: `
                <svg xmlns="http://www.w3.org/2000/svg"
                     viewBox="0 -960 960 960"
                     width="40" height="40"
                     fill="var(--heli-color)">
                    <path d="M360-440v-240q-100 0-170 70t-70 170h240Z
                             M520-80H120v-80h400v80Z
                             M600-200H120q-33 0-56.5-23.5T40-280v-160q0-134
                             93-227t227-93h240v200h200l40-80h80v280l-320
                             32v128Z
                             M760-680H120v-80h640v80Z"/>
                </svg>
            `,
            className: 'leaflet-user-icon',
            iconSize: [40, 40]
        });

        // Create the Leaflet map and center it on a default location (Agder area) with a starting zoom level
        window.map = L.map('map', { minZoom: 4 }).setView([58.1638332, 7.9812789], 16);

        const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(window.map);

        // Expose Stadia API key from Razor to JavaScript
        const stadiaApiKey = '@stadiaApiKey';

        const darkMode = L.tileLayer(
            `https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png?api_key=${stadiaApiKey}`,
            {
                minZoom: 0,
                maxZoom: 20,
                attribution: '&copy; Stadia Maps & OpenMapTiles & OpenStreetMap'
            }
        );

        const stadiaSat = L.tileLayer(
            `https://tiles.stadiamaps.com/tiles/alidade_satellite/{z}/{x}/{y}{r}.jpg?api_key=${stadiaApiKey}`,
            {
                minZoom: 0,
                maxZoom: 20,
                attribution: '&copy; Stadia Maps, Maxar, OpenStreetMap contributors'
            }
        );

        // Layer control to let the user toggle between OSM, dark theme, and satellite basemaps
        L.control.layers(
                { 'OSM': osm, 'Darkmode': darkMode, 'SatView': stadiaSat },
            {},
            { collapsed: false }
        ).addTo(map);


        // Drawing state: references to current marker, polyline and mode used while placing geometry
        let marker = null;
        let latlngs = [];
        let polyline = null;
        let currentMode = null;
        let redDot = [];
        let redDotLayer = L.layerGroup().addTo(map);

        function setMode(mode) {
            if (currentMode === mode) {
                currentMode = null; // clicking the same mode again turns drawing off
            } else {
                currentMode = mode;
            }

            // Visually highlight the active drawing button and reset others
            document.querySelectorAll('.leaflet-control-custom').forEach(btn => {
                btn.style.backgroundColor = (btn.dataset.mode === currentMode) ? 'var(--red-selected-color)' : 'var(--unselected-color)';
              });

            // When leaving polyline mode, remove the line and its red vertex markers
            if (currentMode !== 'polyline') {
                latlngs = [];
                if (polyline) {
                  map.removeLayer(polyline);
                  polyline = null;
                }
                redDotLayer.clearLayers();
                redDot = [];
              }

            // When leaving marker mode, remove the single marker and clear its state
            if (currentMode !== 'marker') {
                latlngs = [];
                if (marker) {
                    map.removeLayer(marker);
                    marker = null;
                }
            }
        }

        map.on('click', (e) => {
            const { lat, lng } = e.latlng;

            const polyColor = getComputedStyle(document.documentElement)
            .getPropertyValue('--polyline-color')
            .trim();

            // Show the last clicked coordinate in the readout bar
            const el = document.querySelector('.coordinate');
            if (el) el.textContent = `lat: ${lat.toFixed(6)}, lng: ${lng.toFixed(6)}`;

            if (currentMode === 'polyline') {
              // First click creates the line, subsequent clicks extend it
              if (!polyline) {
                latlngs = [e.latlng];
                polyline = L.polyline(latlngs, { color: polyColor }).addTo(map);
              } else {
                latlngs.push(e.latlng);
                polyline.setLatLngs(latlngs);
              }

              // Add a small vertex marker (red dot) at each polyline point for visual clarity
              const dot = L.circleMarker(e.latlng, {
                radius: 4,
                   color: polyColor,
                   fillColor:polyColor,
                fillOpacity: 1,
                weight: 0
              }).addTo(redDotLayer);
              dot.bringToFront();
              redDot.push(dot);

            } else if (currentMode === 'marker') {
              if (!marker) {
                marker = L.marker(e.latlng, { draggable: true }).addTo(map);

                // Update coordinate readout live while the marker is dragged
                marker.on('drag', (event) => {
                  const pos = event.target.getLatLng();
                  const el = document.querySelector('.coordinate');
                  if (el) el.textContent = `lat: ${pos.lat.toFixed(6)}, lng: ${pos.lng.toFixed(6)}`;
                });
              } else {
                marker.setLatLng(e.latlng);
              }
            }
        });

        // Custom Leaflet control: button that toggles polyline drawing mode
        const DrawPolylineControl = L.Control.extend({
            onAdd: function () {

                const btn = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom');

                btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px" fill="var(--marker-color)"><path d="M760-80q-50 0-85-35t-35-85q0-14 3-27t9-25L252-652q-12 6-25 9t-27 3q-50 0-85-35t-35-85q0-50 35-85t85-35q50 0 85 35t35 85q0 14-3 27t-9 25l400 400q12-6 25-9t27-3q50 0 85 35t35 85q0 50-35 85t-85 35Z"/></svg>';
                btn.dataset.mode = 'polyline';
                btn.style.backgroundColor = 'var(--base-variant)';
                btn.style.width = '100px';
                btn.style.height = '100px';
                btn.style.cursor = 'pointer';
                btn.style.padding = '5px';
                btn.title = 'Click to start/stop drawing a polyline';

                // Stop the click from affecting the map and switch into polyline mode
                L.DomEvent.on(btn, 'click', L.DomEvent.stopPropagation)
                          .on(btn, 'click', (e) => setMode('polyline'));
                return btn;
            }
        });

        // Custom Leaflet control: button that toggles single-marker placement mode
        const DrawMarkerControl = L.Control.extend({
            onAdd: function () {
                const btn = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom');

                btn.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px" fill="var(--marker-color)">
                        <path d="M480-480q33 0 56.5-23.5T560-560q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 33 23.5 56.5T480-480Zm0 400Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"/>
                    </svg>
                `;

                btn.dataset.mode = 'marker';
                btn.style.backgroundColor = 'var(--base-variant)';
                btn.style.width = '100px';
                btn.style.height = '100px';
                btn.style.cursor = 'pointer';
                btn.style.padding = '5px';
                btn.title = 'Click to start/stop placing markers';

                // Prevent map interactions from this click and enable marker mode instead
                L.DomEvent.on(btn, 'click', L.DomEvent.stopPropagation)
                          .on(btn, 'click', () => setMode('marker'));

                return btn;
            }
        });


        // Add the custom drawing controls (polyline and marker) to the map UI
        map.addControl(new DrawPolylineControl({ position: 'topleft' }));
        map.addControl(new DrawMarkerControl({ position: 'topleft' }));

        // State and helpers for the “follow my location” geolocation feature
        let watchId = null;
        let following = false;
        let userMarker = null;
        let accuracyCircle = null;

        if (map.stopLocate) map.stopLocate();
        map.off('locationfound locationerror');

        // Draw or update the user marker and its accuracy circle on the map
        function renderUserLocation(lat, lng, accuracy) {
            if (!userMarker) {
                userMarker = L.marker([lat, lng], {
                    title: 'You',
                    icon: userIcon,
                }).addTo(window.map);
            } else {
                userMarker.setLatLng([lat, lng]);
            }

            if (!accuracyCircle) {
                accuracyCircle = L.circle([lat, lng], {
                    radius: accuracy,
                    color: '#2a83ff',
                    weight: 0.3,
                    fillColor: '#2a83ff',
                    fillOpacity: 0.1
                }).addTo(window.map);
            } else {
                accuracyCircle.setLatLng([lat, lng]).setRadius(accuracy);
            }
        }

        // Callback used when geolocation successfully returns a position
        function onPositionSuccess(position) {
            const { latitude: lat, longitude: lng, accuracy } = position.coords;
            renderUserLocation(lat, lng, accuracy);
            if (following) {
                map.setView([lat, lng], Math.max(map.getZoom(), 16), { animate: true });
            }
        }

        // Callback used when geolocation fails (e.g. denied, timeout, unavailable)
        function onPositionError(err) {
            const msgs = {
                1: 'Geolocation permission denied. Enable it in your browser.',
                2: 'Position unavailable. Try enabling GPS/location services.',
                3: 'Timeout. Please try again.'
            };
            alert(msgs[err.code] || 'Couldn’t get your position.');
            setFollowing(false);
        }

        // Start continuous geolocation tracking using navigator.geolocation.watchPosition
        function startWatch() {
            if (!('geolocation' in navigator)) {
                alert('Your browser does not support geolocation.');
                return;
            }
            if (watchId !== null) {
                console.log('watchPosition already active:', watchId);
                return;
            }
            console.log('Starting geolocation watch...');
            watchId = navigator.geolocation.watchPosition(onPositionSuccess, onPositionError, {
                enableHighAccuracy: true,
                timeout: 20000,
                maximumAge: 5000
            });
        }


        // Stop continuous geolocation tracking
        function stopWatch() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
        }

        // Determine whether the current origin is secure enough to allow geolocation follow
        function isLocalSecure() {
            return window.isSecureContext ||
                ['localhost', '127.0.0.1', '::1'].includes(location.hostname);
        }

        // Turn following mode on or off and keep UI + geolocation state in sync
        function setFollowing(isOn) {
            following = isOn;

            if (isOn) {
                if (isLocalSecure()) {
                    // Immediately get one current position when follow is activated
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude: lat, longitude: lng, accuracy } = position.coords;
                            renderUserLocation(lat, lng, accuracy);

                            // Move the map view directly to the user’s position
                            map.setView([lat, lng], Math.max(map.getZoom(), 16), { animate: true });

                            // Begin watching for further position updates
                            startWatch();
                        },
                        onPositionError,
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                    );
                } else {
                    alert('Geolocation follow requires HTTPS or localhost/127.0.0.1/::1.');
                    following = false;
                }
            } else {
                stopWatch();
            }

            if (followCtrl && followCtrl.setUi) followCtrl.setUi(following);
        }



        // If the user manually drags or zooms the map, automatically stop following
        map.on('dragstart zoomstart', () => {
            if (following) setFollowing(false);
        });

        // Leaflet control that toggles "follow my location" with a button
        const FollowControl = L.Control.extend({
            onAdd: function () {
                const btn = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom');
                btn.title = 'Find me';
                btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 -960 960 960" width="48px" fill="var(--blueBtn-color)"><path d="m300-300 280-80 80-280-280 80-80 280Zm180-120q-25 0-42.5-17.5T420-480q0-25 17.5-42.5T480-540q25 0 42.5 17.5T540-480q0 25-17.5 42.5T480-420Zm0 340q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"/></svg>';

                btn.style.width = '100px';
                btn.style.height = '100px';
                btn.style.padding = '5px';
                btn.style.cursor = 'pointer';

                L.DomEvent.on(btn, 'click', L.DomEvent.stopPropagation)
                          .on(btn, 'click', () => setFollowing(!following));

                this._btn = btn;
                this.setUi(false);
                return btn;
            },
            setUi: function (isOn) {
                if (!this._btn) return;
                this._btn.title = isOn ? 'Following (click to pause)' : 'Find me';
                this._btn.style.background = isOn ? 'var(--selected-color)' : 'var(--unselected-color)';

            }
        });
        const followCtrl = new FollowControl({ position: 'topleft' }).addTo(window.map);

        // Modal + GeoJSON handling for “Add Report” workflow

        const obstacleBox = document.getElementById('obstacleBox');
        const dlg = document.getElementById('reportDialog');
        const frame = document.getElementById('reportFrame');
        const closeBtn = document.getElementById('reportClose');

        // Make clicks and scrolls on the "Report" box not pan/zoom the map underneath
        L.DomEvent.disableClickPropagation(obstacleBox);
        L.DomEvent.disableScrollPropagation(obstacleBox);

        closeBtn.addEventListener('click', () => dlg.close());
        dlg.addEventListener('cancel', () => dlg.close());

        // Build a GeoJSON FeatureCollection from the current drawing state (marker/polyline/map center)
        function currentLatLngForForm() {
            const features = [];
            // Prefer the user’s placed marker if it exists; otherwise we may fall back to polyline or map center
            if (marker && marker.getLatLng) {
                const ll = marker.getLatLng();


                features.push({
                    type: "Feature",
                    geometry: {
                    coordinates: [parseFloat(ll.lng.toFixed(6)), parseFloat(ll.lat.toFixed(6))]
                },
                properties: {}
                });
            }

            if (polyline && polyline.getLatLngs && polyline.getLatLngs().length > 0) {
                const coords = polyline.getLatLngs().map(p => [
                    parseFloat(p.lng.toFixed(6)),
                    parseFloat(p.lat.toFixed(6))
                ]);
                features.push({
                    type: "Feature",
                    geometry: {
                        type: "LineString",
                        coordinates: coords
                },
                properties: {}
                });
            }
            if (features.length === 0) {
                const c = map.getCenter();
                features.push({
                    type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: [parseFloat(c.lng.toFixed(6)), parseFloat(c.lat.toFixed(6))]
                                },
                                properties: {}
                        });
            }

            return {
                type: "FeatureCollection", features};
        }

        // Determine a representative "first" coordinate from the FeatureCollection for use in the CreatePopUp URL
        function firstLatLng() {
            const geoJson = currentLatLngForForm();
            const firstFeature = geoJson.features[0];

            if (firstFeature.geometry.type === "Point") {
                const [lng, lat] = firstFeature.geometry.coordinates;
                return { lat, lng };

            } else if (firstFeature.geometry.type === "LineString") {
                const [lng, lat] = firstFeature.geometry.coordinates[0];
                return { lat, lng };

            } else {
                // Fallback: if geometry type is unknown, use the map center
                const c = map.getCenter();
                return { lat: c.lat, lng: c.lng };
            }

        }

        obstacleBox.addEventListener('click', (e) => {
            e.preventDefault();

            // Serialize the current drawing state to GeoJSON for sending into the report form
            const geoJsonData = currentLatLngForForm();
            const geoJsonString = JSON.stringify(geoJsonData, null, 2); // pretty-print for readability

            // Compute the initial latitude/longitude and dark-mode flag for the CreatePopUp URL
            const { lat, lng } = firstLatLng();
            const isDarkMode = document.body.classList.contains('darkmode');
            const createUrl =
                '@Url.Action("CreatePopUp", "Reports")' +
                `?lat=${encodeURIComponent(lat)}&lng=${encodeURIComponent(lng)}&darkmode=${isDarkMode}`;

            console.log("Opening Add Report at:", createUrl);
            console.log("GeoJSON to insert:", geoJsonString);

            // Load the CreatePopUp form into the iframe and open the dialog
            frame.src = createUrl;
            dlg.showModal();

            // Once the iframe has loaded, locate the GeoJSON field and inject our serialized data
            frame.onload = () => {
                try {
                    const doc = frame.contentDocument || frame.contentWindow.document;
                    const geoInput = doc.querySelector('[name="NewReport.GeoJson"]');
                    if (geoInput) {
                        geoInput.value = geoJsonString;
                        console.log("GeoJSON inserted into form");
                    } else {
                        console.warn("GeoJSON input not found in CreatePopUp form");
                    }
                } catch (err) {
                    console.error("Could not access iframe form:", err);
                }
            };
        });



    </script>
</body>
</html>
